<!doctype html>
<html lang="en">




<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <title>Skazka — Interactive atlas</title>
  <link rel="icon" type="image/png" href="assets/skazka_logo.png" />
  <link rel="preload" as="image" href="skazka_export.webp" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    html,
    body,
    #map {
      height: 100%;
      margin: 0;
    }

    .leaflet-container {
      background: #0b0e13;
    }

    /* Promote heavy elements early */
    .leaflet-image-layer,
    .leaflet-pane,
    .leaflet-zoom-animated,
    .leaflet-marker-icon,
    .leaflet-tooltip.skz-label {
      will-change: transform;
    }

    /* Permanent labels (counter-scaled after zoom) */
    :root {
      --skz-freeze-scale: 1;
    }

    .leaflet-tooltip.skz-label {
      /* label */
      background: transparent;
      border: none;
      box-shadow: none;
      color: black;
      font-size: 0.8rem;
      font-weight: bolder;
      text-shadow:
        0 0 2px #fff,
        0 0 6px #fff,
        0 0 12px rgba(255, 255, 255, .8);
    }

    .leaflet-zoom-anim .skz-label {
      opacity: .12;
      transition: opacity .12s linear;
    }

    .leaflet-tooltip-left::before,
    .leaflet-tooltip-right::before,
    .leaflet-tooltip-top::before,
    .leaflet-tooltip-bottom::before {
      border: none;
    }

    .leaflet-tooltip-top.skz-label {
      margin-top: -1px;
    }

    /* Popup shell */
    .leaflet-popup.skz-popup-wrap .leaflet-popup-content-wrapper {
      background: #11131a;
      color: #efe9d8;
      border: 1px solid rgba(255, 255, 255, .18);
      border-radius: 10px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, .4);
    }

    .leaflet-popup.skz-popup-wrap .leaflet-popup-tip {
      background: #11131a;
      border: 1px solid rgba(255, 255, 255, .18);
    }

    .skz-popup .t {
      font-weight: 700;
      margin-bottom: 4px;
      color: #efe9d8;
    }

    .skz-popup .d {
      color: #d4cdbb;
      opacity: .9;
      margin: 2px 0 6px;
    }

    .skz-popup a {
      color: #d7c38b;
      text-decoration: none;
    }

    .skz-popup a:hover {
      text-decoration: underline;
    }

    /* Blue diamond icon for Cities */
    .skz-divicon-diamond {
      width: 10px;
      height: 10px;
      position: relative;
      /* no translate here — Leaflet handles anchoring via iconAnchor */
      filter: drop-shadow(0 2px 2px rgba(0, 0, 0, .45)) drop-shadow(0 6px 14px rgba(0, 0, 0, .25));
    }

    .skz-divicon-diamond .gem {
      position: absolute;
      left: 50%;
      top: 1px;
      /* centers the 8×8 diamond inside 10×10 */
      width: 8px;
      height: 8px;
      margin-left: -4px;
      transform: rotate(45deg);
      background: linear-gradient(135deg, #243a73, #0b1633);
      border: 2px solid #8aa2ff;
      border-radius: 2px;
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, .15), inset 0 -8px 12px rgba(0, 0, 0, .35);
    }

    .skz-divicon-diamond:hover .gem {
      filter: brightness(1.08);
    }

    /* Town / Ruin / POI pins */
    .pin {
      width: 10px;
      height: 10px;
      /* no translate — anchor will center these */
    }

    .pin>span {
      display: block;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      border: 2px solid rgba(0, 0, 0, .45);
    }

    /* Town: small blue dot */
    .pin.pin--town {
      width: 10px;
      height: 10px;
    }

    .pin--town>span {
      background: linear-gradient(#8aa0a8, #2b3e4a);
      border-color: #1c2a31;
    }

    /* Ruin: crimson diamond */
    .pin.pin--ruin {
      width: 10px;
      height: 10px;
    }

    .pin--ruin>span {
      background: linear-gradient(#6b3a3a, #2a1818);
      border-color: #2a1818;
      transform: rotate(45deg);
    }

    /* NEW: POI — gold ring */
    .pin.pin--poi {
      width: 10px;
      height: 10px;
    }

    .pin--poi>span {
      background: radial-gradient(circle, transparent 45%, #d7c38b 46% 60%, transparent 61%);
      border-color: #d7c38b;
    }

    /* Kingdom labels: much bigger, wide tracking */
    .leaflet-tooltip.skz-label--kingdom {
      font-size: 20px;
      letter-spacing: 0.2em;
      /* wide spacing */
      font-weight: 800;
      text-transform: uppercase;
    }

    /* Bigger text for cities; tweak to taste */
    .leaflet-tooltip.skz-label--city {
      font-size: 15px;
      color: red;
      font-weight: 700;
    }

    /* Optional: keep others smaller for contrast */
    .leaflet-tooltip.skz-label--town {
      font-size: 12px;
    }



    .leaflet-tooltip.skz-label--poi {
      font-size: 12px;
    }

    .leaflet-tooltip.skz-label--ruin {
      font-size: 12px;
    }

    /* === Right-side UI (search/list) === */
    .skz-ui {
      position: absolute;
      right: 12px;
      top: 12px;
      z-index: 1000;
      width: 280px;
      max-height: calc(100% - 24px);
      overflow: auto;
      background: rgba(18, 19, 25, .88);
      color: #efe9d8;
      border: 1px solid rgba(255, 255, 255, .15);
      border-radius: 12px;
      padding: 10px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, .4);
      backdrop-filter: blur(4px);
      font: 14px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }

    .skz-search {
      width: 100%;
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, .18);
      background: #0f1116;
      color: #efe9d8;
      outline: none;
    }

    .skz-list {
      list-style: none;
      margin: 10px 0 0;
      padding: 0;
    }

    .skz-list li {
      padding: 6px;
      border-radius: 8px;
      cursor: pointer;
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 6px;
    }

    .skz-list li:hover {
      background: rgba(255, 255, 255, .06);
    }

    .skz-list .n {
      font-weight: 700;
    }

    .skz-list .c {
      opacity: .8;
      font-size: 12px;
    }

    .skz-ui,
    .skz-list {
      overflow-x: hidden;
    }

    .skz-list li {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
  </style>
  <link rel="stylesheet" href="https://unpkg.com/@geoman-io/leaflet-geoman-free@2.13.0/dist/leaflet-geoman.css">


</head>

<body>
  <div id="map" role="application" aria-label="Skazka map (perf tuned)"></div>
  <div id="skz-ui" class="skz-ui">
    <input id="skz-search" class="skz-search" placeholder="Find a place…">
    <ul id="skz-list" class="skz-list"></ul>
  </div>


  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/@geoman-io/leaflet-geoman-free@2.13.0/dist/leaflet-geoman.min.js"></script>
  <script>
    // Base image
    const img = { url: "skazka_export.webp", width: 2047, height: 2047 };
    const bounds = [[0, 0], [img.height, img.width]];

    const map = L.map('map', {
      crs: L.CRS.Simple,
      minZoom: -4,
      maxZoom: 2,
      zoomSnap: 0.5,
      markerZoomAnimation: false,
      fadeAnimation: false
      // (add maxBoundsViscosity: 0.8 here if you're using it elsewhere)
    });

    const overlay = L.imageOverlay(img.url, bounds).addTo(map);
    map.fitBounds(bounds);

    // --- Dynamic max bounds so zoom near edges doesn't get clamped
    function refreshMaxBounds() {
      const size = map.getSize();
      const padX = Math.ceil(size.x / 2);
      const padY = Math.ceil(size.y / 2);
      map.setMaxBounds([[-padY, -padX], [img.height + padY, img.width + padX]]);
    }
    map.whenReady(refreshMaxBounds);
    map.on('resize zoomend', refreshMaxBounds);

    const el = overlay.getElement();
    if (el) { el.decoding = 'sync'; el.loading = 'eager'; try { el.fetchPriority = 'high'; } catch (e) { } el.style.willChange = 'transform'; }

    // --- Pane for area polygons (drawn below markers)
    map.createPane('areas');
    map.getPane('areas').style.zIndex = 450; // markerPane is ~600

    // --- Layers
    const Cities = L.layerGroup().addTo(map);
    const Towns = L.layerGroup().addTo(map);
    const Ruins = L.layerGroup().addTo(map);
    const POI = L.layerGroup().addTo(map);
    const Kingdoms = L.layerGroup().addTo(map); // NEW

    L.control.layers(
      null,
      { Cities, Towns, Ruins, POI, Kingdoms }, // include Kingdoms in toggles
      { collapsed: false, position: 'topleft' }
    ).addTo(map);

    // --- Icons
    const CityIcon = L.divIcon({
      className: "skz-divicon-diamond",
      html: "<span class='gem' aria-hidden='true'></span>",
      iconSize: [10, 10], iconAnchor: [5, 9], popupAnchor: [0, -10]
    });
    const TownIcon = L.divIcon({
      className: "pin pin--town", html: "<span></span>",
      iconSize: [10, 10], iconAnchor: [5, 5], popupAnchor: [0, -8]
    });
    const RuinIcon = L.divIcon({
      className: "pin pin--ruin", html: "<span></span>",
      iconSize: [10, 10], iconAnchor: [5, 5], popupAnchor: [0, -8]
    });
    const POIIcon = L.divIcon({
      className: "pin pin--poi", html: "<span></span>",
      iconSize: [10, 10], iconAnchor: [5, 5], popupAnchor: [0, -8]
    });
    const KingdomIcon = L.divIcon({              // NEW
      className: "pin pin--kingdom", html: "<span></span>",
      iconSize: [10, 10], iconAnchor: [5, 5], popupAnchor: [0, -8]
    });

    // --- Lookups
    const layersByName = { Cities, Towns, Ruins, POI, Kingdoms }; // NEW includes Kingdoms
    const iconsByType = { city: CityIcon, town: TownIcon, ruin: RuinIcon, poi: POIIcon, kingdom: KingdomIcon }; // NEW

    // --- Polygon storage + styles (for kingdoms)
    const polygonById = new Map();
    const AREA_BASE_STYLE = {
      color: '#d7c38b',
      weight: 2,
      fillColor: '#d7c38b',
      fillOpacity: 0,   // a bit stronger
      pane: 'areas'
    };
    const AREA_HL_STYLE = {
      color: '#e6cf97',
      fillColor: '#e6cf97',
      fillOpacity: 0.45
    };

    // --- Data load
    let places = []; // global data store used by fetch + search + list
    async function loadPlaces() {
      try {
        const res = await fetch('../data/places.json', { cache: 'no-cache' });
        if (!res.ok) throw new Error(res.status + ' ' + res.statusText);
        const data = await res.json();
        places = Array.isArray(data) ? data : (data.places || []);

        // Place markers
        places.forEach(addPlace);

        // Build list initially
        if (typeof renderList === 'function') renderList(places);
      } catch (err) {
        console.error('Failed to load ../data/places.json', err);
      }
    }
    loadPlaces();

    // --- Markers
    const markerById = new Map();

    function addPlace(p) {
      const layer = layersByName[p.layer] || map;
      const icon = iconsByType[p.type] || CityIcon;

      // visual marker
      const m = L.marker([p.y, p.x], { title: p.name, icon, riseOnHover: true }).addTo(layer);

      // popup (safe link resolution)
      const url = (p.href && p.href !== '#') ? new URL(p.href, document.baseURI).href : null;
      m.bindPopup(
        '<div class="skz-popup">'
        + '<div class="t">' + p.name + '</div>'
        + '<div class="d">' + (p.desc || '') + '</div>'
        + (url ? '<a href="' + url + '" target="_blank" rel="noopener">Open page →</a>' : '')
        + '</div>',
        { className: "skz-popup-wrap", maxWidth: 280, keepInView: true }
      );

      // labels — also label kingdoms by default (your CSS sizes them up)
      const wantsLabel = p.label || p.type === "town" || p.type === "poi" || p.type === "kingdom";
      if (wantsLabel) {
        const labelClass = `skz-label skz-label--${p.type || 'other'}`;
        m.bindTooltip(p.name, { permanent: true, direction: "top", className: labelClass });
      }

      // big invisible hit area for touch
      const hit = L.circleMarker([p.y, p.x], {
        radius: 16, stroke: false, fillOpacity: 0, fillColor: '#000', interactive: true
      }).addTo(layer);
      hit.on('click', () => m.openPopup());
      hit.on('mouseover', () => m.fire('mouseover'));
      hit.on('mouseout', () => m.fire('mouseout'));

      // --- NEW: draw & wire up the kingdom polygon (if provided)
      let poly = null;
      if (p.type === 'kingdom' && Array.isArray(p.area) && p.area.length >= 3) {
        poly = L.polygon(p.area, AREA_BASE_STYLE).addTo(Kingdoms);
        polygonById.set(p.id, poly);
        console.log('Kingdom polygon created:', p.id, poly.getBounds());

        const hlOn = () => poly && poly.setStyle(AREA_HL_STYLE);
        const hlOff = () => poly && poly.setStyle(AREA_BASE_STYLE);

        m.on('mouseover', hlOn);
        m.on('focus', hlOn);
        m.on('popupopen', hlOn);
        m.on('mouseout', hlOff);
        m.on('blur', hlOff);
        m.on('popupclose', hlOff);

        // Also react if you hover the polygon itself
        poly.on('mouseover', hlOn);
        poly.on('mouseout', hlOff);
      }

      markerById.set(p.id, m);
      return m;
    }

    // === Search / list ===
    const $search = document.getElementById('skz-search');
    const $list = document.getElementById('skz-list');

    function renderList(items) {
      $list.innerHTML = items.map(p => `
      <li data-id="${p.id}">
        <span class="n">${p.name}</span>
        <span class="c">${p.layer}</span>
      </li>
    `).join('');
    }
    renderList(places);

    $list.addEventListener('click', (e) => {
      const li = e.target.closest('li[data-id]');
      if (!li) return;
      const p = places.find(x => x.id === li.dataset.id);
      if (!p) return;
      map.flyTo([p.y, p.x], Math.max(map.getZoom(), -1));
      markerById.get(p.id)?.openPopup();
    });

    $search.addEventListener('input', () => {
      const q = $search.value.trim().toLowerCase();
      const filtered = !q ? places
        : places.filter(p => (p.name + ' ' + (p.desc || '') + ' ' + p.layer).toLowerCase().includes(q));
      renderList(filtered);
    });

    // Freeze labels after zoom
    const FREEZE_Z = 2, STATIC_SCALE = 0.7;
    function updateFrozenLabelScale() {
      const z = map.getZoom();
      let scale = 1;
      if (z < FREEZE_Z) {
        const mapScale = map.getZoomScale(z, FREEZE_Z);
        scale = (STATIC_SCALE) / mapScale;
      }
      document.documentElement.style.setProperty('--skz-freeze-scale', scale.toFixed(3));
    }
    map.on('zoomend viewreset', updateFrozenLabelScale);
    map.whenReady(updateFrozenLabelScale);

    // Pre-warm zoom pipeline (avoid first-zoom stutter)
    map.whenReady(() => {
      const z = map.getZoom(), step = 0.5;
      map.setZoom(z + step, { animate: false });
      map.setZoom(z, { animate: false });
    });

    // Helper: click to log coords
    map.on("click", e => console.log("y, x =", Math.round(e.latlng.lat), Math.round(e.latlng.lng)));

    // Show only the polygon tool (top-left by default)
    map.whenReady(() => {
      if (map.pm && typeof map.pm.addControls === 'function') {
        map.pm.addControls({
          position: 'topleft',
          drawPolygon: true,
          drawMarker: false,
          drawPolyline: false,
          drawCircle: false,
          drawCircleMarker: false,
          drawRectangle: false,
          cutPolygon: false,
          editMode: true,
          dragMode: false,
          removalMode: true
        });
      } else {
        console.error('Leaflet-Geoman failed to load: map.pm is undefined.');
      }
    });

    // When a polygon is finished, capture coords (CRS.Simple -> [y,x]),
    // copy JSON to clipboard, and add a styled Kingdom polygon to your layer.
    map.on('pm:create', (e) => {
      if (e.shape !== 'Polygon') return;

      const latlngs = e.layer.getLatLngs()[0];            // first ring
      const coordsYX = latlngs.map(ll => [Math.round(ll.lat), Math.round(ll.lng)]); // [y,x]
      const json = JSON.stringify(coordsYX);

      console.log('Kingdom area coords [y,x]:', json);
      if (navigator.clipboard) navigator.clipboard.writeText(json).catch(() => { });

      // Replace the editable layer with your normal kingdom polygon (in 'areas' pane)
      e.layer.remove();
      const poly = L.polygon(latlngs, AREA_BASE_STYLE).addTo(Kingdoms);
      poly.on('mouseover', () => poly.setStyle(AREA_HL_STYLE));
      poly.on('mouseout', () => poly.setStyle(AREA_BASE_STYLE));
    });
  </script>

</body>

</html>